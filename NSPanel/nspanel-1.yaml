esphome:
  name: nspanel-1
  comment: Sonoff NSPanel 01 - Korytarz

esp32:
  board: esp32dev

# Enable logging
logger:
  level: DEBUG

# Enable Home Assistant API
api:
  id: api_id
  services:
    # Expose "send_json" to Home Assistant for scripts/testing
    - service: send_json
      variables:
        my_type: int
        my_json: string
      then:
        - lambda: 'id(nspanel1).send_json_command(my_type,my_json);'
    - service: play_rtttl
      variables:
        song_str: string
      then:
        - rtttl.play:
            rtttl: !lambda 'return song_str;'

ota:
  password: "123456"

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  manual_ip:
    static_ip: 192.168.50.151
    gateway: 192.168.50.1
    subnet: 255.255.255.0
    dns1: 8.8.8.8
    dns2: 192.168.50.165

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "Nspanel-1 Fallback Hotspot"
    password: "1234567890"

captive_portal:

time:
  - platform: homeassistant
    id: homeassistant_time
    timezone: Europe/Warsaw
    
# HTTP Request component needed for wttr.in weather web query
http_request:
  useragent: esphome/device
  timeout: 5s
  
substitutions:
# Unique ID for Sensors.
  switch_id: "nsp01"
  friendly_name: "NSPanel 01"
  #location for weather
  wttr_location: "52.2946518,20.9299804"

uart:
  tx_pin: 16
  rx_pin: 17
  baud_rate: 115200
  
# Use Local modified NSPanel component
external_components:
  - source: github://pr#2702
    components: ["nspanel"]
    refresh: 0s

# Update Weather Interval
interval:
  - interval: 30min
    then:
       - script.execute: nspanel_weather

# NSPanel Component for access to panel.
# Updates temperature, date, time, Relay indicators
# Provides JSON interface to panel
nspanel:
  id: nspanel1
  time_id: homeassistant_time
  temperature: ${switch_id}_temperature
  eco_mode_switch: ${switch_id}_eco_mode
  screen_power_switch: ${switch_id}_screen_power
  relays:
    - ${switch_id}_relay_1
    - ${switch_id}_relay_2
  on_json_message:
    then:
      # Widget 1 (type:0x86 id:light.living_room) - Salon
      - if:
          condition:
            lambda: 'return (type == 0x86 && root.containsKey("id") && strcasecmp(root["id"], "light_salon") == 0);'
          then:
            - if:
                condition:
                  lambda: 'return (root["params"].containsKey("switch") && root["params"]["switch"] == "on");'
                then:
                  - homeassistant.service:
                      service: light.turn_on
                      data:
                        entity_id: light.living_room
            - if:
                condition:
                  lambda: 'return (root["params"].containsKey("switch") && root["params"]["switch"] == "off");'
                then:
                  - homeassistant.service:
                      service: light.turn_off
                      data:
                        entity_id: light.living_room
            - if:
                condition:
                  lambda: 'return (root["params"].containsKey("white"));'
                then:
                  - homeassistant.service:
                      service: light.turn_on
                      data:
                        entity_id: light.living_room
                        brightness: !lambda 'return int(root["params"]["white"]["br"].as<float>() / 100 * 255);'
      # Widget 2 (type:0x86 id:light.living_room_rgb) - Salon RGB
      - if:
          condition:
            lambda: 'return (type == 0x86 && root.containsKey("id") && strcasecmp(root["id"], "wled_salon") == 0);'
          then:
            - if:
                condition:
                  lambda: 'return (root["params"].containsKey("switch") && root["params"]["switch"] == "on" && !root["params"].containsKey("bright"));'
                then:
                  - homeassistant.service:
                      service: light.turn_on
                      data:
                        entity_id: light.living_room_rgb
            - if:
                condition:
                  lambda: 'return (root["params"].containsKey("switch") && root["params"]["switch"] == "off");'
                then:
                  - homeassistant.service:
                      service: light.turn_off
                      data:
                        entity_id: light.living_room_rgb
            - if:
                condition:
                  lambda: 'return (root["params"].containsKey("bright"));'
                then:
                  - homeassistant.service:
                      service: script.set_light_on_rgb
                      data:
                        entity_name: light.living_room_rgb
                        brightness: !lambda 'return int(root["params"]["bright"].as<float>() / 100 * 255);'
                        red: !lambda 'return root["params"]["colorR"].as<int>();'
                        green: !lambda 'return root["params"]["colorG"].as<int>();'
                        blue: !lambda 'return root["params"]["colorB"].as<int>();'
      # Widget 3 (type:0x86 id:light.light_ikea_sypialnia) - Sypialnia
      - if:
          condition:
            lambda: 'return (type == 0x86 && root.containsKey("id") && strcasecmp(root["id"], "light_sypialnia") == 0);'
          then:
            - if:
                condition:
                  lambda: 'return (root["params"].containsKey("switch") && root["params"]["switch"] == "on");'
                then:
                  - homeassistant.service:
                      service: light.turn_on
                      data:
                        entity_id: light.light_ikea_sypialnia
            - if:
                condition:
                  lambda: 'return (root["params"].containsKey("switch") && root["params"]["switch"] == "off");'
                then:
                  - homeassistant.service:
                      service: light.turn_off
                      data:
                        entity_id: light.light_ikea_sypialnia
            - if:
                condition:
                  lambda: 'return (root["params"].containsKey("white"));'
                then:
                  - homeassistant.service:
                      service: light.turn_on
                      data:
                        entity_id: light.light_ikea_sypialnia
                        brightness: !lambda 'return int(root["params"]["white"]["br"].as<float>() / 100 * 255);'
      # Widget 4 (type:0x86 id:light.sonoff_1000ee2034) - Sypialnia RGB
      - if:
          condition:
            lambda: 'return (type == 0x86 && root.containsKey("id") && strcasecmp(root["id"], "wled_sypialnia") == 0);'
          then:
            - if:
                condition:
                  lambda: 'return (root["params"].containsKey("switch") && root["params"]["switch"] == "on" && !root["params"].containsKey("bright"));'
                then:
                  - homeassistant.service:
                      service: light.turn_on
                      data:
                        entity_id: light.sonoff_1000ee2034
            - if:
                condition:
                  lambda: 'return (root["params"].containsKey("switch") && root["params"]["switch"] == "off");'
                then:
                  - homeassistant.service:
                      service: light.turn_off
                      data:
                        entity_id: light.sonoff_1000ee2034
            - if:
                condition:
                  lambda: 'return (root["params"].containsKey("bright"));'
                then:
                  - homeassistant.service:
                      service: script.set_light_on_rgb
                      data:
                        entity_name: light.sonoff_1000ee2034
                        brightness: !lambda 'return int(root["params"]["bright"].as<float>() / 100 * 255);'
                        red: !lambda 'return root["params"]["colorR"].as<int>();'
                        green: !lambda 'return root["params"]["colorG"].as<int>();'
                        blue: !lambda 'return root["params"]["colorB"].as<int>();'
      # Widget 6 - Scene Spanie
      - if:
          condition:
            lambda: 'return (type == 0x86 && root.containsKey("id") && strcasecmp(root["id"], "alarm_night") == 0);'
          then:
            - homeassistant.service:
                service: alarm_control_panel.alarm_arm_night
                data:
                  entity_id: alarm_control_panel.home_alarm
      # Widget 7 - Scene Spanie
      - if:
          condition:
            lambda: 'return (type == 0x86 && root.containsKey("id") && strcasecmp(root["id"], "alarm_disarm") == 0);'
          then:
            - homeassistant.service:
                service: alarm_control_panel.alarm_disarm
                data:
                  entity_id: alarm_control_panel.home_alarm
      # Widget 8 - Scene Spanie
      - if:
          condition:
            lambda: 'return (type == 0x86 && root.containsKey("id") && strcasecmp(root["id"], "scene_sleep") == 0);'
          then:
            - homeassistant.service:
                service: scene.turn_on
                data:
                  entity_id: scene.spanie
      # Thermostat (type:0x84) 
      - if:
          condition:
            lambda: 'return (type == 0x84);'
          then:
            - if:
                condition:
                  lambda: 'return (root.containsKey("ATCEnable") && root["ATCEnable"] == 1);'
                then:
                  - homeassistant.service:
                      service: climate.turn_on
                      data:
                        entity_id: climate.shed
            - if:
                condition:
                  lambda: 'return (root.containsKey("ATCEnable") && root["ATCEnable"] == 0);'
                then:
                  - homeassistant.service:
                      service: climate.turn_off
                      data:
                        entity_id: climate.shed
            - if:
                condition:
                  lambda: 'return (root.containsKey("ATCExpect0"));'
                then:
                  - homeassistant.service:
                      service: climate.set_temperature
                      data:
                        entity_id: climate.shed
                        temperature: !lambda 'return root["ATCExpect0"].as<int>();'
                        hvac_mode: heat
    
output:
  - platform: ledc
    id: ${switch_id}_buzzer_out
    pin:
      number: 21

rtttl:
  id: ${switch_id}_buzzer
  output: ${switch_id}_buzzer_out
  
button:
  # Restart Button in HA
  - platform: restart
    name: "${switch_id} Restart"
    device_class: restart

number:
  platform: template
  name: "${switch_id} Brightness"
  id: brightness
  entity_category: config
  unit_of_measurement: '%'
  min_value: 0
  max_value: 100
  step: 1
  initial_value: 50
  set_action:
    then: #json type 87 for screen brightness
      - lambda: 'id(nspanel1).send_json_command(0x87, "");'

switch:
  - platform: gpio
    # Panel Left Hand relay
    name: ${switch_id} Relay 1
    id: ${switch_id}_relay_1
    pin:
      number: 22
  - platform: gpio
    # Panel Right Hand relay
    name: ${switch_id} Relay 2
    id: ${switch_id}_relay_2
    pin:
      number: 19
  - platform: gpio
    # Panel Screen Power
    name: ${switch_id} Screen Power
    id: ${switch_id}_screen_power
    entity_category: config
    pin:
      number: 4
      inverted: true
    restore_mode: ALWAYS_OFF
    on_turn_on:
      # Initiliase Screen - These timings could be more aggressive
      then:
        - delay: 6s
        - logger.log: "[nspanel_boot] starting screen"
        - script.execute: nspanel_init
        - delay: 3s
        - logger.log: "[nspanel_boot] updating Wi-Fi state"
          # Must send Wifi State for widgets to update (particulalry after power-on of screen only
          # code taken from within NSPanel component code
        - lambda: |-
            uint8_t rssi = 0;
            rssi = (wifi::global_wifi_component->wifi_rssi() * -1) / 20.0f;
            std::string json_str = json::build_json([rssi](JsonObject root) {
              root["wifiState"] = "connected";
              root["rssiLevel"] = rssi;
            });
            id(nspanel1).send_json_command(0x85, json_str);
        - if:
            condition:
              api.connected:
            then:
              - logger.log: "[nspanel_boot] Home Assistant API is connected!"
        - logger.log: "[nspanel_boot] starting weather service"
        - script.execute: nspanel_weather
        - logger.log: "[nspanel_boot] boot sequence completed."
  - platform: template
    # Template switch to enable/disable screen dimming
    name: ${switch_id} Energy Saving Mode
    id: ${switch_id}_eco_mode
    entity_category: config
    restore_state: true
    optimistic: true
    
binary_sensor:
# NS Panel Hard Switches
  - platform: gpio
    id: ${switch_id}_button_1
    name: ${switch_id} Left Button
    pin:
      number: 14
      inverted: true
    on_click:
      - switch.toggle: ${switch_id}_relay_1
  - platform: gpio
    id: ${switch_id}_button_2
    name: ${switch_id} Right Button
    pin:
      number: 27
      inverted: true
    on_click:
      - switch.toggle: ${switch_id}_relay_2
# HA Tracking sensors for device states
# Update nspanel on state change
  - platform: homeassistant
    id: dim_light_salon
    entity_id: light.living_room
    on_press:
      then:
        - lambda: 'id(nspanel1).send_json_command(0x86,"{\"id\":\"light_salon\",\"params\":{\"switch\":\"on\"}}");'
    on_release:
      then:
        - lambda: 'id(nspanel1).send_json_command(0x86,"{\"id\":\"light_salon\",\"params\":{\"switch\":\"off\"}}");'
  - platform: homeassistant
    id: wled_light_salon
    entity_id: light.living_room_rgb
    on_press:
      then:
        - lambda: 'id(nspanel1).send_json_command(0x86,"{\"id\":\"wled_salon\",\"params\":{\"switch\":\"on\"}}");'
    on_release:
      then:
        - lambda: 'id(nspanel1).send_json_command(0x86,"{\"id\":\"wled_salon\",\"params\":{\"switch\":\"off\"}}");'
  - platform: homeassistant
    id: dim_light_sypialnia
    entity_id: light.light_ikea_sypialnia
    on_press:
      then:
        - lambda: 'id(nspanel1).send_json_command(0x86,"{\"id\":\"light_sypialnia\",\"params\":{\"switch\":\"on\"}}");'
    on_release:
      then:
        - lambda: 'id(nspanel1).send_json_command(0x86,"{\"id\":\"light_sypialnia\",\"params\":{\"switch\":\"off\"}}");'
  - platform: homeassistant
    id: wled_light_sypialnia
    entity_id: light.sonoff_1000ee2034
    on_press:
      then:
        - lambda: 'id(nspanel1).send_json_command(0x86,"{\"id\":\"wled_sypialnia\",\"params\":{\"switch\":\"on\"}}");'
    on_release:
      then:
        - lambda: 'id(nspanel1).send_json_command(0x86,"{\"id\":\"wled_sypialnia\",\"params\":{\"switch\":\"off\"}}");'
sensor:
# Extra sensor to keep track of plug uptime
  - platform: uptime
    name: ${switch_id} Uptime Sensor
# Wifi Signal
  - platform: wifi_signal
    name: "${switch_id} WiFi Signal Sensor"
    update_interval: 60s
# nspanel related temperature sensors
  - platform: adc
    id: ${switch_id}_ntc_source
    pin: 38
    update_interval: 10s
    attenuation: 11db
  - platform: resistance
    id: ${switch_id}_resistance_sensor
    sensor: ${switch_id}_ntc_source
    configuration: DOWNSTREAM
    resistor: 11.2kOhm
  - platform: ntc
    id: ${switch_id}_temperature
    sensor: ${switch_id}_resistance_sensor
    calibration:
      b_constant: 3950
      reference_temperature: 27°C
      reference_resistance: 10kOhm
    name: "${switch_id} Temperature"
# Home Assistant Light State Sensors to update panel
  - platform: homeassistant
    # Light light.living_room brightness (0-255)
    id: living_room_bright
    entity_id: light.living_room
    attribute: brightness
    on_value:
      then:
        - script.execute: ha_dim_light_salon_update
  - platform: homeassistant
    # Light light.living_room_rgb_bright brightness (0-255)
    id: living_room_rgb_bright
    entity_id: light.living_room_rgb
    attribute: brightness
    on_value:
      then:
        - script.execute: ha_wled_salon_update
  - platform: homeassistant
    # Light light.light_ikea_sypialnia brightness (0-255)
    id: bedroom_bright
    entity_id: light.light_ikea_sypialnia
    attribute: brightness
    on_value:
      then:
        - script.execute: ha_dim_light_sypialnia_update
  - platform: homeassistant
    # Light light.sypialnia_rgb_bright brightness (0-255)
    id: bedroom_rgb_bright
    entity_id: light.sonoff_1000ee2034
    attribute: brightness
    on_value:
      then:
        - script.execute: ha_wled_sypialnia_update
  - platform: homeassistant
    # Thermostat set temp
    id: climate_temp
    name: ${switch_id} Climate Temp
    entity_id: climate.shed
    attribute: temperature
    internal: true
    on_value:
      then:
        - script.execute: ha_thermostat_update_temp
text_sensor:
# Text Sensors to track attirbutes from HA (HA -> Panel)
  - platform: homeassistant
    name: "HA Salon RGB"
    id: living_room_rgb_rgb
    entity_id: light.living_room_rgb
    attribute: rgb_color
    internal: false
    on_value:
      then:
        - script.execute: ha_wled_salon_update
  - platform: homeassistant
    name: "HA Sypialnia RGB"
    id: bedroom_rgb_rgb
    entity_id: light.sonoff_1000ee2034
    attribute: rgb_color
    internal: false
    on_value:
      then:
        - script.execute: ha_wled_sypialnia_update
  - platform: homeassistant
    id: climate_state
    name: "Climate State"
    entity_id: climate.shed
    internal: true
    on_value:
      then:
        - script.execute: ha_thermostat_update_state
script:
  - id: ha_dim_light_salon_update
    then:
      - lambda: |-
          if (id(dim_light_salon).state) {
            int i_brightness = int(id(living_room_bright).state / 255 * 100); 
            id(nspanel1).send_json_command(0x86,"{\"id\":\"light_salon\",\"params\":{\"switch\":\"on\",\"ltype\":\"white\",\"white\":{\"br\":" + to_string(i_brightness) + "}}}");
          } else {
            id(nspanel1).send_json_command(0x86,"{\"id\":\"light_salon\",\"params\":{\"switch\":\"off\"}}");
          }
  - id: ha_wled_salon_update
    # Decode RGB Attribute ((r,g,b) and send to panel
    then:
      - lambda: |-
          if (id(wled_light_salon).state) {
            int i_brightness = int(id(living_room_rgb_bright).state / 255 * 100); 
            std::string s = id(living_room_rgb_rgb).state;
            std::string r = "255";
            std::string g = "0";
            std::string b = "0";
            int p1 = s.find(",");
            if (p1 > 0) {
                int p2 = s.find(",",p1+1);
                r = s.substr(1, p1-1).erase(0,s.find_first_not_of(" ")); 
                g = s.substr(p1+2,p2-p1-2).erase(0,s.find_first_not_of(" ")); 
                b = s.substr(p2+2,s.length()-2).erase(0,s.find_first_not_of(" ")); 
            }
            id(nspanel1).send_json_command(0x86,"{\"id\":\"wled_salon\",\"params\":{\"switch\":\"on\",\"light_type\":1,\"mode\":1,\"bright\":" + to_string(i_brightness) + ",\"colorR\":" + to_string(r) + ",\"colorG\":" + to_string(g) + ",\"colorB\":" + to_string(b) + "}}");
          } else {
            id(nspanel1).send_json_command(0x86,"{\"id\":\"wled_salon\",\"params\":{\"switch\":\"off\"}}");
          }
  - id: ha_dim_light_sypialnia_update
    then:
      - lambda: |-
          if (id(dim_light_sypialnia).state) {
            int i_brightness = int(id(bedroom_bright).state / 255 * 100); 
            id(nspanel1).send_json_command(0x86,"{\"id\":\"light_sypialnia\",\"params\":{\"switch\":\"on\",\"ltype\":\"white\",\"white\":{\"br\":" + to_string(i_brightness) + "}}}");
          } else {
            id(nspanel1).send_json_command(0x86,"{\"id\":\"light_sypialnia\",\"params\":{\"switch\":\"off\"}}");
          }
  - id: ha_wled_sypialnia_update
    # Decode RGB Attribute ((r,g,b) and send to panel
    then:
      - lambda: |-
          if (id(wled_light_sypialnia).state) {
            int i_brightness = int(id(bedroom_rgb_bright).state / 255 * 100); 
            std::string s = id(bedroom_rgb_rgb).state;
            std::string r = "255";
            std::string g = "0";
            std::string b = "0";
            int p1 = s.find(",");
            if (p1 > 0) {
                int p2 = s.find(",",p1+1);
                r = s.substr(1, p1-1).erase(0,s.find_first_not_of(" ")); 
                g = s.substr(p1+2,p2-p1-2).erase(0,s.find_first_not_of(" ")); 
                b = s.substr(p2+2,s.length()-2).erase(0,s.find_first_not_of(" ")); 
            }
            id(nspanel1).send_json_command(0x86,"{\"id\":\"wled_sypialnia\",\"params\":{\"switch\":\"on\",\"light_type\":1,\"mode\":1,\"bright\":" + to_string(i_brightness) + ",\"colorR\":" + to_string(r) + ",\"colorG\":" + to_string(g) + ",\"colorB\":" + to_string(b) + "}}");
          } else {
            id(nspanel1).send_json_command(0x86,"{\"id\":\"wled_sypialnia\",\"params\":{\"switch\":\"off\"}}");
          }
  - id: ha_thermostat_update_state
    then:
      # Update Thermostat On/Off
      - lambda: |-
          if (id(climate_state).state == "heat") { 
           id(nspanel1).send_json_command(0x84,"{\"ATCEnable\":1}");
          } else {
           id(nspanel1).send_json_command(0x84,"{\"ATCEnable\":0}");
          }
  - id: ha_thermostat_update_temp
    then:
      # Update Thermostat Temperature
      - lambda: |-
          if ( (int) id(climate_temp).state > 15 && (int) id(climate_temp).state < 32 && id(climate_state).state == "heat") {
            id(nspanel1).send_json_command(0x84,"{\"ATCExpect0\":" + to_string((int) id(climate_temp).state) + "}");
          }
  - id: nspanel_init
    # Script to initialise panel on full power on (or when screen is powered on from ESP)
    then:
      # Setup Widgets - must send all 8
      # Widget 1
      - lambda: |-
          id(nspanel1).send_json_command(0x86,"{\"HMI_resources\":[{\"index\":1,\"ctype\":\"device\",\"id\":\"light_salon\",\"uiid\":52}]}"); id(nspanel1).send_json_command(0x86,"{\"relation\":[{\"ctype\":\"device\",\"id\":\"light_salon\",\"name\":\"Salon\",\"online\":1,\"params\":{\"switch\":\"off\",\"ltype\":\"white\",\"white\":{\"br\":0,\"ct\":0}}]}");
      # Widget 2
      - lambda: |-
          id(nspanel1).send_json_command(0x86,"{\"HMI_resources\":[{\"index\":2,\"ctype\":\"device\",\"id\":\"wled_salon\",\"uiid\":33}]}");
          id(nspanel1).send_json_command(0x86,"{\"relation\":[{\"ctype\":\"device\",\"id\":\"wled_salon\",\"name\":\"Salon RGB\",\"online\":1,\"params\":{\"switch\":\"on\"}]}");
      # Widget 3
      - lambda: |-
          id(nspanel1).send_json_command(0x86,"{\"HMI_resources\":[{\"index\":3,\"ctype\":\"device\",\"id\":\"light_sypialnia\",\"uiid\":52}]}"); id(nspanel1).send_json_command(0x86,"{\"relation\":[{\"ctype\":\"device\",\"id\":\"light_sypialnia\",\"name\":\"Sypialnia\",\"online\":1,\"params\":{\"switch\":\"off\",\"ltype\":\"white\",\"white\":{\"br\":0,\"ct\":0}}]}");
      # Widget 4
      - lambda: |-
          id(nspanel1).send_json_command(0x86,"{\"HMI_resources\":[{\"index\":4,\"ctype\":\"device\",\"id\":\"wled_sypialnia\",\"uiid\":33}]}");
          id(nspanel1).send_json_command(0x86,"{\"relation\":[{\"ctype\":\"device\",\"id\":\"wled_sypialnia\",\"name\":\"Bed RGB\",\"online\":1,\"params\":{\"switch\":\"on\"}]}");
      # Widget 5
      - lambda: |-
          id(nspanel1).send_json_command(0x86,"{\"HMI_resources\":[{\"index\":5,\"ctype\":\"scene\",\"id\":\"alarm_night\"}]}");
          id(nspanel1).send_json_command(0x86,"{\"relation\":[{\"ctype\":\"scene\",\"id\":\"alarm_night\",\"name\":\"Arm alarm\"}]}");
      # Widget 6
      - lambda: |-
          id(nspanel1).send_json_command(0x86,"{\"HMI_resources\":[{\"index\":6,\"ctype\":\"scene\",\"id\":\"alarm_disarm\"}]}");
          id(nspanel1).send_json_command(0x86,"{\"relation\":[{\"ctype\":\"scene\",\"id\":\"alarm_disarm\",\"name\":\"Disarm\"}]}");
      # Widget 7
      - lambda: 'id(nspanel1).send_json_command(0x86,"{\"index\":7,\"type\":\"delete\"}");'
      # Widget 8
      - lambda: |-
          id(nspanel1).send_json_command(0x86,"{\"HMI_resources\":[{\"index\":8,\"ctype\":\"scene\",\"id\":\"scene_sleep\"}]}");
          id(nspanel1).send_json_command(0x86,"{\"relation\":[{\"ctype\":\"scene\",\"id\":\"scene_sleep\",\"name\":\"Spanie\"}]}");
      # Update existing Entities / Widgets
      - logger.log: "[nspanel_boot] updating widgets state"
      - script.execute: ha_dim_light_salon_update
      - script.execute: ha_wled_salon_update
      - script.execute: ha_dim_light_sypialnia_update
      - script.execute: ha_wled_sypialnia_update
      # Setup Thermostat
      - lambda: 'id(nspanel1).send_json_command(0x84,"{\"HMI_ATCDevice\":{\"ctype\":\"device\",\"id\":\"climate\",\"outlet\":0,\"etype\":\"hot\"}}");'
      - lambda: 'id(nspanel1).send_json_command(0x84,"{\"ATCMode\":0}");'
      # Update Thermostat
      - logger.log: "[nspanel_boot] updating thermostate state"
      - script.execute: ha_thermostat_update_state
      - script.execute: ha_thermostat_update_temp
  - id: nspanel_weather
    # Grab weather status (JSON) from https://wttr.in
    then:
      - logger.log: "[nspanel_weather] started"
      - lambda: |-
          WiFiClientSecure client;
          HTTPClient http;
          bool begin_status = false;
          int httpCode = 0;
          int wicon,wicon_out;
          std::string buffer;
          // Disable certificate checking
          client.setInsecure();
          
          ESP_LOGD("nspanel_weather", "Init Complete");
          //use appropriate location - test in browser without "?format=j2" for normal output
          begin_status = http.begin(client,"wttr.in",443,"/${wttr_location}?format=j2",true);
          if(!begin_status){
            ESP_LOGD("nspanel_weather", "http.begin failed");
          } else {
            ESP_LOGD("nspanel_weather", "http.begin OK");
          }
          http.useHTTP10(true);
          ESP_LOGD("nspanel_weather", "http.useHTTP10 flag set");
          ESP_LOGD("nspanel_weather", "http.GET");
          httpCode = http.GET();
          if(!httpCode){
            ESP_LOGD("nspanel_weather", "http.GET NOK");
          } else {
            ESP_LOGD("nspanel_weather", "http.GET OK");
          }
          if (httpCode > 0) {
            // http response received
            ESP_LOGD("nspanel_weather", "HTTP response code is %i", httpCode);
            if (httpCode == HTTP_CODE_OK || httpCode == HTTP_CODE_MOVED_PERMANENTLY) {
              // setup JSON object for HTTP response
              DynamicJsonDocument root(4000);
              DeserializationError error = deserializeJson(root, http.getStream());
              if (root.containsKey("current_condition")) {
                ESP_LOGD("nspanel_weather", "JSON Parse OK");
                wicon = int( root["current_condition"][0]["weatherCode"].as<signed int>());
                ESP_LOGD("nspanel_weather", "weather code received: %i", wicon);
                
                // Translate wttr.in weather code to use correct nspanel icon
                // Mapping from Tasmota nspanel.be code
                wicon_out = 30; // Unknown / Default
                if (wicon == 113) { wicon_out = 1; }  //    # Sunny      
                if (wicon == 116) { wicon_out = 2; }  //    # PartlyCloudy   
                if (wicon == 119) { wicon_out = 2; }  //    # Cloudy             
                if (wicon == 122) { wicon_out = 7; }  //    # VeryCloudy           
                if (wicon == 143) { wicon_out = 11; } //    # Fog                 
                if (wicon == 176) { wicon_out = 40; } //    # LightShowers     
                if (wicon == 179) { wicon_out = 24; } //    # LightSleetShowers 
                if (wicon == 182) { wicon_out = 24; } //    # LightSleet        
                if (wicon == 185) { wicon_out = 24; } //    # LightSleet        
                if (wicon == 200) { wicon_out = 42; } //    # ThunderyShowers  
                if (wicon == 227) { wicon_out = 20; } //    # LightSnow  
                if (wicon == 230) { wicon_out = 22; } //    # HeavySnow        
                if (wicon == 260) { wicon_out = 11; } //    # Fog                 
                if (wicon == 263) { wicon_out = 40; } //    # LightShowers     
                if (wicon == 266) { wicon_out = 40; } //    # LightRain      
                if (wicon == 281) { wicon_out = 24; } //    # LightSleet        
                if (wicon == 284) { wicon_out = 24; } //    # LightSleet        
                if (wicon == 293) { wicon_out = 40; } //    # LightRain      
                if (wicon == 296) { wicon_out = 40; } //    # LightRain      
                if (wicon == 299) { wicon_out = 18; } //    # HeavyShowers      
                if (wicon == 302) { wicon_out = 18; } //    # HeavyRain        
                if (wicon == 305) { wicon_out = 18; } //    # HeavyShowers      
                if (wicon == 308) { wicon_out = 18; } //    # HeavyRain        
                if (wicon == 311) { wicon_out = 24; } //    # LightSleet        
                if (wicon == 314) { wicon_out = 24; } //    # LightSleet        
                if (wicon == 317) { wicon_out = 24; } //    # LightSleet        
                if (wicon == 320) { wicon_out = 20; } //    # LightSnow  
                if (wicon == 323) { wicon_out = 22; } //    # LightSnowShowers 
                if (wicon == 326) { wicon_out = 22; } //    # LightSnowShowers 
                if (wicon == 329) { wicon_out = 22; } //    # HeavySnow        
                if (wicon == 332) { wicon_out = 22; } //    # HeavySnow        
                if (wicon == 335) { wicon_out = 29; } //    # HeavySnowShowers   
                if (wicon == 338) { wicon_out = 22; } //    # HeavySnow        
                if (wicon == 350) { wicon_out = 24; } //    # LightSleet        
                if (wicon == 353) { wicon_out = 24; } //    # LightSleet        
                if (wicon == 356) { wicon_out = 18; } //    # HeavyShowers      
                if (wicon == 359) { wicon_out = 18; } //    # HeavyRain        
                if (wicon == 362) { wicon_out = 24; } //    # LightSleetShowers 
                if (wicon == 365) { wicon_out = 24; } //    # LightSleetShowers 
                if (wicon == 368) { wicon_out = 22; } //    # LightSnowShowers 
                if (wicon == 371) { wicon_out = 29; } //    # HeavySnowShowers   
                if (wicon == 374) { wicon_out = 24; } //    # LightSleetShowers 
                if (wicon == 377) { wicon_out = 24; } //    # LightSleet        
                if (wicon == 386) { wicon_out = 42; } //    # ThunderyShowers  
                if (wicon == 389) { wicon_out = 42; } //    # ThunderyHeavyRain  
                if (wicon == 392) { wicon_out = 42; } //    # ThunderySnowShowers
                if (wicon == 395) { wicon_out = 29; } //    # HeavySnowShowers   
                // Create JSON to update nspanel
                // Weather Code for weather icon
                // Current Temp = current_0["temp_C"]
                // Temp range min = weather_0["mintempC"]
                // Temp range max = weather_0["maxtempC"]
                id(nspanel1).send_json_command(0x81,"{\"HMI_weather\":" + to_string(wicon_out) + ",\"HMI_outdoorTemp\":{\"current\":" + root["current_condition"][0]["temp_C"].as<const char*>() + ",\"range\":\"" +root["weather"][0]["mintempC"].as<const char*>() + "," +  root["weather"][0]["maxtempC"].as<const char*>() + "\"}}");
              } else {
                ESP_LOGD("nspanel_weather", "Current weather condition not found, JSON parsing failed");
              }
            } else {
              ESP_LOGD("nspanel_weather", "Wrong HTTP response: %i", httpCode);
            }
          } else {
            ESP_LOGD("nspanel_weather", "No HTTP response");
          }
      - logger.log: "[nspanel_weather] weather update completed"
